% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CIVMR_function.R
\name{smooth_CIV}
\alias{smooth_CIV}
\title{CIV_smooth solution with cross-validation.(recommended)}
\usage{
smooth_CIV(G, X, Z, Y, lambda_list = NULL, k_folds = 10, sigma_min = 0.01,
  sigma_up = 0.5, stepsize = 0.1, conv_iters = 5, stepsize_last = 1e-04,
  last_conv_iters = 2000, method_lambda = "er", n_IV = 100)
}
\arguments{
\item{initial:}{the initial value for updating u.}

\item{G:}{SNP matrix with dimension \eqn{n \times p}.}

\item{X:}{phenotype of interest.}

\item{Z:}{pleiotropic phenotype Z.}

\item{Y:}{the disease outcome Y.}

\item{lambda_list:}{a list of values for regularization parameter lambda. A default list will be chosen if not provided.}

\item{k_folds:}{number of folds for cross-validation (to find optimum \eqn{\lambda}). default = 10.}

\item{n_IV:}{the number of initial points chosen to explore potential multiple modes. The converged
solutions will be screened to delete redundant solutions. So the final solutions will be less or equal to n_IV. default = 100.}

\item{sigma_min:}{the minimum value of \eqn{\sigma} (corresponding to the closeast approximation of \eqn{L_0} penalty). default = 0.01.}

\item{sigma_up:}{the moving down multiplier. \eqn{\sigma_{j+1} = sigma_up \times \sigma_{j}}. default = 0.5.}

\item{stepsize:}{the stepsize to move solution u. default = 0.1.}

\item{conv_iters:}{the maximum steps to allow updating when a converged solution is found. default =5.}

\item{stepsize_last:}{When a converged solution is found with stepsize, we update this solution with a smaller stepsize to achive a more precise
local maximum solution. default = 0.0001.}

\item{last_conv_iters:}{the maximum iterations to run in the stage of ``refining" optimum solution. default = 2000.}

\item{......:}{default values for other tuning parameters.}
}
\value{
opt_lambda: the chosen optimum value of \eqn{\lambda} corresponding to the minimum projected prediction error (see paper).

IV_mat: the final matrix of CIV instruments with respect to the opt_lambda. Each column is a new instrument.

u_mat: the final CIV solutions of u with respect to the opt_lambda. Each column is a converged solution.

G_pred_error_list: the projected prediction error according to the list values of \eqn{\lambda}.

Pred_error_list: the prediction error according to the list values of \eqn{\lambda}.
}
\description{
This function first find the optimal value of \eqn{\lambda} according
to projected prediction error with cross-validation. Then for a given \eqn{\lambda} value multiple intial
points are used to explore potentially multiple modes.
}
\examples{
data(simulation)
G <- simulation$G
X <- simulation$X
Z <- simulation$Z
Y <- simulation$Y
smooth.opt <- smooth_CIV( G,X,Z,Y, k_folds = 10)
plot(smooth.opt$u_mat[,1])  #plot a solution u.
}

